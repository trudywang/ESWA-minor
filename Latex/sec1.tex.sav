\section{Introduction}
Shortest path query systems are now widely seen in the daily life \citep{wu2012shortest,potamias2009fast,wei2010tedi,liu2011generalization,
cheng2012efficient}.
People who use Google or Baidu maps usually request shortest paths to restaurants, car parks, cinemas, playgrounds, shopping malls and so on.
When a user has a shortest path query, a cache in a local server is accessed; the result, if exists, will be directly returned to the user. If the cache does not have an off-the-shelf result to the query, the system accesses a global server which runs a shortest path algorithm for the result. The latter situation undoubtedly costs communication and computational time \citep{altingovde2009cost,baeza2007impact,Kriegel2008Hierarchical,gan2009improved,markatos2001caching}. The contents in caches are therefore, very critical for the efficiency of the whole query system.

In the shortest path caching problem, existing works all discuss the cache initialization problem, that is, given a road network and a query log, how to load an empty cache in order to make the cache work in a high-efficiency level in the future. Researchers usually select paths with the highest query frequencies into caches, or those paths that contain the most numbers of nodes~\citep{thomsen2012effective,li2013}.
The situation of a road network cannot remain the same all the time; on contrast, it changes frequently.
For example, rush hours or traffic congestion change the weight of some edges on a road network.
When a road network changes, if paths in the cache are not adjusted, some paths in the cache may become invalid or the utilization of the cache decreases.
How to maintain a cache based on the changes of a road network is seldom discussed in the literature.
Apparently, a straightforward way to refresh a cache is to empty the cache and conduct an initialization process once more. Such a method is too naive, because evaluating all the shortest paths once more is time-consuming.

In this paper, we discuss how to refresh a cache when the weight of a certain edge changes. Assuming that only one edge changes its weight is reasonable. On one hand, studying the scenario of single edge change is a good point to start from. We can draw some conclusions from single-edge scenario which still stand for the multiple-edge scenario. On the other hand, traffic congestion may happen in main streets and these main streets are far away from each other and unrelated.

We first develop a cache structure based on a structure of bitmap to store and give access to shortest paths. We then develop algorithms to detect affected shortest paths as a consequence of edge change. Next, we design four strategies to refresh the cache and compare their performance.
Our work contributes to the literature in two aspects. First, to the best of our knowledge, our work is the first one to discuss the shortest path caching problem with a changed graph. This problem is undoubtedly more close to real applications. Second, four cache refreshment strategies are proposed to update the cache. It is noteworthy that this work is an extension of \cite{Li2014refreshment} which is published in a conference. This article extends the initial work, by 1) adopting bitmap index to efficiently answer the shortest path queries; 2) introducing several optimization techniques to further improve the efficiency of detecting affected shortest paths; 3) performing more comprehensive experiments on real data sets, including Aalborg, Beijing and Singapore road network. The data set of Singapore is newly added, and the conference version does not have this data set.

%This scenario depicts situations in practice where a main road has traffic congestion (increased weight), or traffic congestion on a main road is reduced (decreased weight).

%\modify{
%The shortest path cache refreshment problem we have studied in this paper falls into the scope of intelligent systems. The methodologies and strategies used, such as randomness, wheel of fortune, frequency first strategy, also belong to intelligent systems where can load cache in an intelligence manner and thus help improve efficiency of computing query.
%}

The rest of the paper is organized as follows. In Section~\ref{sec:rw}, we review works which are related to the shortest path caching problem.
%In Section~\ref{sec:pre}, we introduce all the concepts and formally define the problem.
In Section~\ref{sec:Cache Structure}, we formally define the problem and design a bitmap-based cache structure to store shortest paths.
Then we explore the properties of changed graphs and present our algorithm for detecting affected shortest paths in Section~\ref{sec:detect-affected}.
It is followed by four cache refreshment strategies in Section~\ref{sec:strategies}.
In Section~\ref{sec:exp}, we conduct experimental comparisons of the proposed methods on real data sets.
Finally, we give some closing remarks in Section~\ref{sec:con}.


\section{Literature Review}
\label{sec:rw}
\fixme{we should give the notion of affected shortest path in introduction section.}
The published works that related with our problem can be broadly classified into two classes. One is detecting affected shortest paths when the weight of edge in graph changes, while the other addresses the problem of caching shortest paths.

\subsection{Detecting Affected Shortest Paths in a Dynamic Graph }\fixme{Should we use dynamic or changed to describe graph?}

In our scenario, all the updating operations are occurred in the local servers, storage spaces are used to cache shortest paths as many as possible, leaving no spare space to store extra information for updating shortest paths.
Therefore, as the weight of graph edge changes, we need to find out the affected shortest paths in cache in a online fashion. Some existing works have been studied to solve the problem of shortest path updating in a dynamic network, next we review the related works on predictable network models, continuous evaluation of shortest path query and single source shortest path update algorithms.

\textbf{Predictable Network Models}. Some works aim to find the expected fastest(in our paper we define it as shortest) path based on the predicted network costs(i.e. they consider the predictable network as dynamic graph). In details, \cite{kanoulas2006finding} develop the concept of speed pattern to specify the predicted network cost at different time, the fastest paths corresponding to different time can be computed based on the predicted network cost. \cite{fu1998expected} model the cost of each edge as a continuous stochastic process to estimate the edge cost, and then find the expected fastest paths. Similarly, \cite{ding2008finding} use time-delay functions to represent the predicted edge costs. However, in our scenario, we consider the dynamic networks as unpredictable, the edge cost is assumed to change quickly and then remain invariable until next changes.

\textbf{Continuous Evaluation of Shortest Path Query}. Continuous evaluation of shortest path query has been studied in \cite{lee2007,tian2009monitoring}, which actually solves the problem of detecting affected shortest paths in dynamic road networks. \cite{lee2007} proposes an ellipse bound method (EBM), where each shortest path corresponds to an elliptic geographical area, called affected area, and all the updated edges are considered to affect their corresponding paths. EBM can solve this problem when source and destination nodes are given in an online fashion. However, for our scenario, it needs to perform the algorithm for each shortest path in cache, which will result in costly computations. Although \cite{lee2007} propose a method to process more than on continuous shortest path query simultaneously, a grid-based index structure is needed to record all the affecting areas. In \cite{tian2009monitoring}, an index, named QSI, is needed to identify the shortest paths affected by the network changes. Both the above methods require extra storages, which is infeasible in our scenario.

\textbf{Single Source Shortest Path Update Algorithms}. Single source shortest path update algorithms have been studied in \cite{bauer2009batch,d2013dynamically,frigioni1996fully,narvaez2000new,mcquillan1980new}.
In general, these algorithms preprocess the shortest paths starting from given source node, and store them as a shortest path tree(SPT). To update the SPT, the basic idea is to utilize the information of the outdated SPT and update only the part of the SPT that is affected by the changed edge. However, for the shortest paths in cache, they cannot be stored in a single shortest path tree. Alternatively, although we can generate multiple SPT to represent the shortest paths, we still need to perform the algorithm for each SPT, which is a expensive operation, especially there exist many SPT.

Besides, in order to accelerate the computation for shortest path, some works develop the preprocessing techniques by computing additional data in a preprocessing phase. Arc-Flags is a typical approach proposed by \cite{lauther2004extremely} designed for static network. \cite{berrettini2009arc,d2014fully} study the problem of updating Arc-Flags in dynamic network.

\iffalse
With respect to the monitoring of shortest paths, \cite{lee2007} proposes an ellipse bound method (EBM), where each shortest path corresponds to an elliptic geographical area and all the updated edges are considered to affect their corresponding paths. The shortcoming of such a method is that they cover a large number of unrelated edges and a lot of computational time is wasted to re-compute unchanged paths. \cite{tian2009monitoring} develops the notion of query scope to identify paths invalidation and devise a partial path computation algorithm (PPCA) to quickly re-compute the updated paths. PPCA achieves superior performance in query processing time, however, it may lead more I/O cost due to extra network traversals, and it does not suit for the case that the network changes a lot. \cite{d2014fully} dynamically updates Arc-Flags to support speed-up techniques on changing networks, however, it needs to maintain a shortest path tree and the preprocessing of Arc-Flags is also very time-consuming.
\fi


\subsection{Caching Strategy for Shortest Paths}

Another previous works related with our problem is caching. Caching techniques have been studied extensively in many domains, such as database systems(\cite{o1993lru}) and web search engines(\cite{markatos2001caching}). Since our caching strategy works on the scenario of caching shortest paths, next we review the related works of caching on the directions web search caching and shortest path caching.

\textbf{Web Search Caching}.
In \cite{markatos2001caching}, caching strategy has been classified into dynamic caching and static caching. Dynamic caching focuses on caching the results of the most recently accessed queries(\citep{gan2009improved,Long2005Three-Level,markatos2001caching}), this caching strategy keeps cache up-to-date to the distribution of the new arrival queries. Static caching aims to cache the results of the most popular queries(\cite{altingovde2009cost,baeza2003three,baeza2007impact}). In general, this caching strategy need to utilize the history query log to discover them most frequent queries, and the static cache usually updates periodically based on the latest query log.

\textbf{Shortest Path Caching}. Some works have been studied in the caching of shortest path(\cite{thomsen2012effective,li2013,thomsen2014concise}). In details, \cite{thomsen2012effective} is the pioneering work on caching of shortest paths,

\modify{
Another previous works related with our problem is caching. Caching technologies has been widely adopted to improve the performance of search engines. \citep{markatos2001caching} is the pioneering work which studies this problem. It classifies caching strategies into two segregated problems based on whether there are changes occur on original data: static caching and dynamic caching.
}



\modify{
\textbf{Static caching}. For the static caching, through \cite{altingovde2009cost,baeza2003three,baeza2007impact}, an interesting finding is that the frequency of queries basically follows a Zipfian distribution, where a small portion of queries appear frequently in the query log. Moreover, these popular queries typically last for quite a long period of time. Therefore by exploiting a query log which records previous queries, static caching figures out the most frequent queries as the most popular ones, and loads them into cache.
\cite{thomsen2012effective} and \cite{li2013} carry out static caching techniques for caching shortest paths. They utilize statistics from query logs to estimate the benefit of caching a shortest path and employ greedy algorithms to load beneficial paths to caches. At the same time, the cache utilization is maximized.
However, both methods fully rely on the historical logs, making cached contents over fit the queries in historical logs. As we all know, logs and future queries only have similar trends in a time period, however, they cannot be totally the same.
}



\modify{
\textbf{Dynamic caching}. For the dynamic caching \citep{gan2009improved,Long2005Three-Level,markatos2001caching}, no work talks about how to refresh a shortest path cache dynamically, especially when the underlying graph changes. Refreshment of conventional caches has been studied, which concentrates on adaption to incoming queries.
Taking the Least-Recently-Used method as an example, whenever a cache fails to answer a request, the least recently used result in a cache is replaced by the currently queried result. With the help of its most up-to-date merit, this approach adapts quickly to new queries; but on the other hand, to maintain the cache up-to-date, this approach incurs overhead for frequently updating the cache.
}


\modify{
It is commonly known that HQF and LRU are not efficient enough for the shortest path caching.
\textbf{Hybrid caching}. Static Dynamic Cache (SDC) method is proposed in \cite{Fagni2006Boosting}. It is a new caching strategy which aims to efficiently exploit the temporal and spatial locality presented in the stream of processed queries. SDC extracts the results of the most frequently submitted queries from historical usage data and stores them in a static, read-only portion of the cache. The remaining entries of the cache are dynamically managed according to a given replacement policy and are used for those queries that cannot be satisfied by the static portion.
}


